---
title: "DNA Diet Methods Pipeline Comparison Supplement"
author: "Ana Miller-ter Kuile"
date: "5/15/2020"
output:
  word_document:
    toc: no
  html_document:
    theme: readable
    code_folding: hide
    toc: no
    df_print: paged
---
# DNA Diet Methods Pipeline Comparison Analyses

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

```{r packages required, include = FALSE}
library(ggplot2)
library(tidyverse)
library(here)
library(cowplot)
library(fitdistrplus)
```

## Motivation
This project creates a workflow for analyzing the diets of invertebrate predators using high throughput sequencing of gut contents. This method provides a promising way to get highly-resolved diet data from consumers across ecosystems. 

**Bioinformatics challenge**: To extract all possible prey items from predator guts when predator and prey are taxonomoically similar, it is best practice to use a set of PCR primers that target all possible prey. However, a side effect of this is that these primers will also end up amplifying a large amount of predator DNA. As a result, these datasets are dominated by predator DNA, and so detecting relatively rare prey sequences in these datasets is key. As the molecular ecology field moves toward using amplicon sequence variants (ASVs) as biologically-real units of biodiversity in high throughput datasets, these types of datsets dominated by predator DNA are even more challenging since these ASV clustering pipelines use sequence abundance as a way to cluster sequences into similar, biologically-real groups of sequences. Therefore, any clustering pipeline used for DNA diet data dominated by the predator must 

  + detect prey sequences that are taxonomically similar to the DNA of predators and
  
  + detect prey sequences that are relatively rare compared to the DNA of predators

```{r ASV assignment figure, echo=FALSE, out.width="100%", fig.align='center', fig.cap = "Figure 1: Denoising pipelines (including DADA2 and UNOISE3) consider sequence abundance and error rate in raw sequence datasets when removing sequences that have high error and low abundance and combining their reads with those of their most similar neighbor sequence with high abundance and low error (amplicon sequence variants or ASVs). Because our dataset has high abundance predator DNA with lower abundance prey DNA, any denoising pipeline we use must accurately be able to distinguish low abundance prey ASVs from high abundance predator ASVs."}
knitr::include_graphics(here("Pictures", "denoise_picture.png"))
```
  

This supplement assesses how different denoising/clustering pipelines perform with these types of datasets and provide a template for other studies interested in interactions between invertebrate predators and prey, but with the idea that the same sort of process could work well for other study systems (i.e. vertebrates that eat vertebrates) as well.

## The data

The data for this project consists of 56 individuals of the spider species *Heteropoda venatoria* from Palmyra Atoll National Wildlife Refuge. We collected 37 of these individuals in the field in 2015 and immediately froze them in a -80C freezer until processing in 2019. The remaining 19 individuals we collected in 2017, starved in mesocosms in the lab for 24 hours, and then fed a known diet item (the grasshopper *Oxya japonica*). After spiders had been in mesocosms with prey items and eaten them (12-24 hours), we froze them at -20C. Prior to final preservation in 80% EtOH, we surface sterilized 8 of these 19 individuals by submerging them in a 10% bleach to DI water solution for 2 minutes and then washing them in DI water for 2 minutes. We performed the same sterilization protocol on 18 of the 37 field-collected individuals after we had brought them to the lab from the field (in 2019). (see Methods document for full extraction, PCR, and sequencing protocols). 

```{r experimental setup, echo=FALSE, out.width="100%", fig.align='center', fig.cap = "Figure 3: Our surface-contamination experiment included four groups of varying sample sizes: both field-collected and lab-fed sterilized individuals and unsterilized individuals."}
knitr::include_graphics(here("Pictures", "experiment_setup.png"))
```

We ran all samples on an Illumina MiSeq platform at the UCSB Genetics Core. We cleaned low-quality sequences from this set of ~15 million sequences returned from the genetics core, and then used two clustering pipelines (DADA2 and UNOISE3) that use sequence abundance and quality to combine similar sequences (which are often different because of errors in amplification or sequencing and actually represent the same sequence) into clusters representing the most common real sequence. We performed each of these clustering pipelines twice: once on the complete list of sequences, and once on a set of sequences that had been "cleaned" of predator and non-diet sequences using the program BBSplit. After the denoising/clustering process, we are left with a matrix very similar to any community matrix, with columns corresponding to each sample (spider individual) and rows corresponding to ASVs (sequences) in that individual. In this way, each spider becomes functionally a "community" of species which can be treated very similarly to any other matrix of community data (i.e. in vegan with multidimensional analyses, etc). 

```{r an example matrix, echo=FALSE}
matrix_example <- read.csv(here("data", 
                                "data_raw",
                                "1_denoised_data", 
                                "ASV_tables",
                                "dada2_uc_asv_tab.tsv"), sep= "\t")

matrix_example_small <- matrix_example[1:10,]
matrix_example_smaller <- matrix_example_small[c(1, 4:9)]
head(matrix_example_smaller, n=10)
```

## Outline of pipeline performance

  + *Clustering specificity*: Positive and negative controls map to fewer ASVs
  
  + *Total ASVs (richness)*: A greater number of ASVs means a higher likelihood the full diversity of the sample has been detected
  
  + *Number of prey ASVs (diet richness)*: A higher diet richness means the pipeline better distinguishes prey ASVs from predator
  
  + *Phylogenetic diversity of prey ASVs*: A better pipeline will detect a broader phylogenetic diversity of prey
  
  + *Prey read abundance*: More prey reads means a higher likelihood of picking up rarer prey items
  
  + *Percent of ASVs that are prey*: This corrects for variable sequencing depth and a higher percentage means a higher likelihood that all prey are detected
  
  + *Percent of reads that are prey*: Again, correcting for sequencing depth, a higher percentage means a higher likelihood that all prey are detected
  
  + *Amount of known diet reads*: A better pipeline will be better at detecting a diet item we KNOW to be present in all samples
  
## Want just the highlights? Jump to the [summary](#pipelines)

## Pipeline performance

```{r pipeline perfomance setup, include=FALSE}
#ASV table Summaries
#Ana Miller-ter Kuile
#February 14, 2020

#This script will look at the ASV/ZOTU tables created by each of my pipelines for prey
#items (dada2 and unoise with clean and unclean) and summarise each based on items of
#interest, including:
#1. positive and negative control mapping

#2. total number of ASVs for each pipeline/individual (uc, prey, predator, unmapped)
#both TOTAL and per sample

#the following require binding the combined MEGAN/BOLD taxonomy ID dataframe:

#3. total number of prey ASVs for each pipeline
#both TOTAL and per sample

#4. total prey ASV read abundance (raw)
#both TOTAL and per sample

#5. proportion of prey to other ASVs (number of ASVs)

#6. proportion of prey reads to other ASVs (raw read abundance)
###a. consider here sequencing depth? Ask Austen

#7. Predator/prey ASV ratios

#8. predator/prey read abundance (raw)

#9. amount of known diet item for lab-fed (raw reads)

#10. amount of knwon diet item for lab-fed (num of ASVs)

#11. Phylogenetic diversity of prey ASVs

#Load required packages####
library(here)
library(tidyverse)
library(ggplot2)
library(emmeans)
#library(rcompanion)
library(effects)
library(lattice)
library(DHARMa)
library(MuMIn)
library(glmmTMB)
library(picante)
library(ape)
library(phytools)
#library(phyloseq)

#import metadata
metadata <- read.csv(here("data", 
                          "data_raw",
                          "2_sample_data",
                          "Sample_Metadata.csv"))

#Import ASV tables####
d2_uc <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "dada2_uc_asv_tab.tsv"), sep = "\t")

d2_c <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "dada2_c_prey_asv_tab.tsv"), sep = '\t')

d2_um <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "dada2_c_um_asv_tab.tsv"), sep = '\t')

d2_pred <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "dada2_c_pred_asv_tab.tsv"), sep = '\t')

u3_uc <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "unoise_uc_zotu_tab.txt"), sep = '\t')

u3_c <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                      "ASV_tables", 
                      "unoise_c_prey_zotu_tab.txt"), sep = '\t')

u3_um <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "unoise_c_um_zotu_tab.txt"), sep = '\t')

u3_pred <- read.csv(here("data",
                       "data_raw",
                       "1_denoised_data", 
                       "ASV_tables", 
                       "unoise_c_pred_zotu_tab.txt"), sep = '\t')

#rename X to ASV in all these tables.
d2_uc <- rename(d2_uc, "ASV" = "X")
d2_c <- rename(d2_c, "ASV" = "X")
d2_um <- rename(d2_um, "ASV" = "X")
d2_pred <- rename(d2_pred, "ASV" = "X")
u3_uc <- rename(u3_uc, "ASV" = "X.OTU.ID")
u3_c <- rename(u3_c, "ASV" = "X.OTU.ID")
u3_um <- rename(u3_um, "ASV" = "X.OTU.ID")
u3_pred <- rename(u3_pred, "ASV" = "X.OTU.ID")

#remove "prey_ref_" and "pred_ref_" from the sample names in dada2 datasets:
for ( col in 1:ncol(d2_c)){
  colnames(d2_c)[col] <-  sub("prey_ref_*", "", colnames(d2_c)[col])
}

for ( col in 1:ncol(d2_pred)){
  colnames(d2_pred)[col] <-  sub("predator_ref_*", "", colnames(d2_pred)[col])
}

#rename all the sample names across dataframes for consistency
colnames(d2_uc) <- sapply(str_split(colnames(d2_uc), "_"), function(x){return(x[[1]])})
colnames(d2_uc) <- str_remove(colnames(d2_uc), "\\.")

d2_uc <- rename(d2_uc, "CL1" = "CL12")
d2_uc <- rename(d2_uc, "CL4" = "CL42")
colnames(d2_pred) <- sapply(str_split(colnames(d2_pred), "_"), function(x){return(x[[1]])})
colnames(d2_pred) <- str_remove(colnames(d2_pred), "\\.")

colnames(d2_c) <- sapply(str_split(colnames(d2_c), "_"), function(x){return(x[[1]])})
colnames(d2_c) <- str_remove(colnames(d2_c), "\\.")

colnames(d2_um) <- sapply(str_split(colnames(d2_um), "_"), function(x){return(x[[1]])})
colnames(d2_um) <- str_remove(colnames(d2_um), "\\.")

d2_um <- rename(d2_um, "CL1" = "CL12")
d2_um <- rename(d2_um, "CL4" = "CL42")
colnames(u3_uc) <- sapply(str_split(colnames(u3_uc), "S"), function(x){return(x[[1]])})
u3_uc <- rename(u3_uc, "ASV" = "A")

#these are all fine
#colnames(u3_c)
#colnames(u3_um)
#colnames(u3_pred)
```

```{r controls mapping, include = FALSE}
#1. positive and negative control mapping ####
#dada2 uncleaned
cl1_d2uc <- d2_uc %>%
  summarise(count = sum(CL1 != 0)) %>% #1
  mutate(pipeline = "d2uc", control = "CL1") 
cl4_d2uc <- d2_uc %>%
  summarise(count = sum(CL4 != 0)) %>% 
  mutate(pipeline = "d2uc", control = "CL4") #1
qc1_d2uc <- d2_uc %>%
  summarise(count = sum(QC1 != 0)) %>%
  mutate(pipeline = "d2uc", control = "CL4") #1
#NEG is ZERO
neg_d2uc <- as.data.frame(0)
neg_d2uc <- neg_d2uc %>%
  mutate(pipeline = "d2uc", control = "NEG") %>%
  rename("count" = "0")


#usearch uncleaned
cl1u3uc <- u3_uc %>%
  summarise(count = sum(CL1 != 0)) %>% #3
  mutate(pipeline = "u3uc", control = "CL1")
cl4u3uc <- u3_uc %>%
  summarise(count = sum(CL4 != 0)) %>% #3
  mutate(pipeline = "u3uc", control = "CL4")
qc1u3uc <- u3_uc %>%
  summarise(count = sum(QC1 != 0)) %>% #3
  mutate(pipeline = "u3uc", control = "QC1")
negu3uc <- u3_uc %>%
  summarise(count = sum(NEG != 0)) %>% #1
  mutate(pipeline = "u3uc", control = "NEG")

#both cleaned map to zero
d2ccont <- as.data.frame(0)
d2ccont <- d2ccont %>%
  mutate(pipeline = "d2c", control = "ALL") %>%
  rename("count" = "0")

u3ccont <- as.data.frame(0)
u3ccont <- u3ccont %>%
  mutate(pipeline = "u3c", control = "ALL") %>%
  rename("count" = "0")
#bind all these together into a dataframe
control_counts <- bind_rows(cl1_d2uc, cl4_d2uc, qc1_d2uc,
                            neg_d2uc, cl1u3uc, cl4u3uc, qc1u3uc,
                            negu3uc, d2ccont, u3ccont)

control_count_plot <- ggplot(control_counts, aes(x = pipeline, y = count)) +
    geom_boxplot() +
    labs(x = "Pipeline", y = "Number of ASVs per control", title = "Number of ASVs mapped to each positive and negative control") +
    theme_bw()

#controls drop out of the cleaned datasets
#and they drop out of these as well, and negative goes to predator with one ASV
colnames(d2_pred)
colnames(u3_pred)
u3_pred %>%
  summarise(sum(NEG != 0)) #1

#no new ASVs get mapped in the cleaned out unmapped sequences 
u3_um %>%
  summarise(sum(CL1 != 0))#3
u3_um %>%
  summarise(sum(CL4 != 0))#3
u3_um %>%
  summarise(sum(QC1 != 0))#3

d2_um %>%
  summarise(sum(CL1 != 0))#1
d2_um %>%
  summarise(sum(CL4 != 0))#1
d2_um %>%
  summarise(sum(QC1 != 0))#1
#Summary: cleaning does not add any ASVs to the controls, and dada2 maps better to controls
```



```{r}
#non-zero reads should only be in the positive control samples:
u3_pos_ct <- u3_uc %>%
  filter(ASV %in% c("Zotu4", "Zotu2", "Zotu3")) %>%
  gather(sample, reads, CL1:QC1) %>%
  filter(reads > 0) %>%
  mutate(type = "u3")

############################
#Justify UNOISE vs. DADA2####
############################
#also, in justifying UNOISE, want to check that the positives got more reads
#NOTE: PUT THIS IN THE PIPELINE COMPARISON SCRIPT!!!!####
d2 <- read.csv(here("data",
                    "data_raw",
                    "1_denoised_data",  
                    "ASV_tables", 
                    "dada2_uc_asv_tab.tsv"), sep = "\t") 

colnames(d2) <- sapply(str_split(colnames(d2), "_"), function(x){return(x[[1]])})
d2 <- rename(d2, "ASV" = "X")

d2_pos_cont <- d2_uc %>%
  filter(ASV %in% c("ASV_10", "ASV_2", "ASV_16")) %>%
  gather(sample, reads, CL1:QC1) %>%
  filter(reads > 0) %>%
  mutate(type = "d2")

positive <- u3_pos_ct %>%
  bind_rows(d2_pos_cont) %>%
  group_by(sample, type) %>%
  summarise(reads = sum(reads))

pos_reads <- positive %>%
  group_by(type) %>%
  summarise(mean = mean(reads), sd =sd(reads), total = n(), se = sd/sqrt(total)) %>%
  ggplot(aes(x = type, y = mean)) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_bw() +
  labs(x = "Pipeline", y ="Average reads per positive control") +
  geom_errorbar(aes(ymin = mean -se, ymax = mean+se))
```

```{r tot ASVs, include = FALSE}
#2. total number of ASVs for each pipeline/individual (uc, prey, predator, unmapped) ####
#dada2 uc
nrow(d2_uc) #214 total ASVs
#by sample:
d2_ASVct <- d2_uc %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, ASVs_d2uc, ASV:QC1, factor_key = TRUE) 

#unoise3 uc
nrow(u3_uc) #176 total ASVs
#by sample:
u3_ASVct <- u3_uc %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, ASVs_u3uc, ASV:QC1, factor_key = TRUE)

#dada2 c
nrow(d2_c) #138 total ASVs
#by sample:
d2c_ASVct <- d2_c %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, ASVs_d2c, ASV:HEV89, factor_key = TRUE)

#unoise3 c
nrow(u3_c) #99 total ASVs
#by sample:
u3c_ASVct <- u3_c %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, ASVs_u3c, ASV:HEV99, factor_key = TRUE)

#join these two together
by_sample <- d2_ASVct %>%
  full_join(d2c_ASVct, by = "sample") %>%
  full_join(u3_ASVct, by = "sample") %>%
  full_join(u3c_ASVct, by = "sample")

by_sample_ster <- by_sample %>%
  left_join(metadata, by = "sample")

ASV_tot_ster <- by_sample_ster %>%
  dplyr::select(ASVs_d2uc, ASVs_d2c, ASVs_u3uc, ASVs_u3c, Sterilized, Source) %>%
  gather(pipeline, value, ASVs_d2uc:ASVs_u3c) %>%
  group_by(pipeline, Sterilized)
#total ASVs
total_ASVs <- by_sample %>%
  filter(sample == "ASV") %>%
  gather(pipeline, value, ASVs_d2uc:ASVs_u3c)

total_asv_graph <- ggplot(ASV_tot_ster, aes(x = pipeline, y = value)) +
  geom_bar(stat = "identity", position = "dodge") + 
  labs(x = "Pipeline", y = "Total ASVs", 
       title = "Total ASVs produced for each pipeline") + theme_bw() 


#and remove the control samples for glmm below
by_sample <- by_sample %>%
  filter(!sample %in% c("ASV", "CL1", "CL4", "QC1", "NEG"))

by_sample_long <- by_sample %>%
  gather(pipeline, value, ASVs_d2uc:ASVs_u3c, factor_key=TRUE)

#join with sample metadata so we can split by field and lab 
#and then use sterilization in the models 
by_sample_long <- by_sample_long %>%
  left_join(metadata, by = "sample")

#create binary sterilized factor
tot_ASV_mod <- glmmTMB(value ~ pipeline + (1|sample),
                       data = by_sample_long,
                       family = "genpois",
                       REML = FALSE)

tot_ASV_mod_null <- glmmTMB(value ~ 1 + (1|sample),
                       data = by_sample_long,
                       family = "genpois", 
                       REML = FALSE)

#assess the corrected AIC for these models:
AICc(tot_ASV_mod, tot_ASV_mod_null)

tot_ASV_mod <- glmmTMB(value ~ pipeline + (1|sample),
                          data = by_sample_long,
                          family = "genpois")

model.emm_totASV <- emmeans(tot_ASV_mod, "pipeline")
pairs(model.emm_totASV)


x_totASV <- residuals(tot_ASV_mod)
plot(x_totASV)
#residuals look relatively normal
plot(residuals(tot_ASV_mod)) #residuals look fairly homoskedastic
plot(allEffects(tot_ASV_mod))
#Unoise unclean produced significantly more ASVs per sample than any other
#pipeline. cleaning significantly decreased the number of ASVs per sample for 
#both pipelines. Sterilization marginally reduced the number of ASVs per sample
#because the interaction was non-significant, the effect of sterilization
#on total ASVs did not differe by pipeline.

#checking other model assumptions here:
simulationOutput_totASV <- simulateResiduals(fittedModel = tot_ASV_mod) 
totASVfit <- plot(simulationOutput_totASV, asFactor=TRUE) #these look good
totASVzi <- testZeroInflation(simulationOutput_totASV) #not zero inflated
totASVod <- testDispersion(simulationOutput_totASV) #not overdispersed

#and that boxplot here
ASV_sample_plot <- ggplot(by_sample_long, aes(x = pipeline, y = value)) +
  geom_boxplot() + theme_bw() +
  labs(x = "Pipeline", y = "ASVs per sample", 
       title = "Total number of ASVs per sample by pipeline") 

#cleaned out
nrow(d2_um) #52
nrow(d2_pred) #38
nrow(u3_um) #72
nrow(u3_pred) #25

#all cleaned added
nrow(d2_c) + nrow(d2_um) + nrow(d2_pred) #228
nrow(u3_c) + nrow(u3_um) + nrow(u3_pred) #196
```

```{r, include = FALSE}
#Intermediate: Bind BOLD and NCBI taxonomies ####
#For some MEGAN assignments, I subset two groups - one with everything that is likely diet
#(which I assigned taxonomies to) and everything else into an ALL_taxa category, which
#included mostly fungi and some other non-diet items which will be under a non-diet cateogry
#for some other MEGAN assignments, the list was small enough that I just created one
#ALL_taxa file, which will get the same types of assignments. 
#The end goal of this section is to have a dataframe which matches ASVs in the community
#matrix for each pipeline (clean and unclean) to their taxonomic categories
#DADA2 UNCLEAN#
#import both NCBI and BOLD taxonomies
d2_uc_ncbi <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                            "MEGAN", 
                            "dada2_unclean",
                            "dada2_uc_ncbi_taxa.csv"))
#this is everything that got a taxonomic assignment through MEGAN
d2_uc_all <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies", 
                           "MEGAN", 
                           "dada2_unclean",
                           "dada2_uc_all.csv"))

d2_uc_bold <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                            "BOLD", 
                            "dada2_uc", 
                            "dada2_uc_taxa_bold.csv"))

d2_uc_bold <- rename(d2_uc_bold, "ASV" = "Query.ID")

#Sort by "predator", "prey", and "non-diet" before merging into one 
#dataframe for assigning to the abundance table!
#this following ifelse set will depend on the taxonomy of the set of samples
#and for this one, these are the categories that seemed to be appropriate based
#on the taxonomy list after looking at it
#sort into categories for bold:
d2_uc_bold$taxonomy <- ifelse(
  d2_uc_bold$ID == "Heteropoda venatoria", "predator",
  ifelse(d2_uc_bold$Kingdom == "Fungi", "non-diet", 
         ifelse(d2_uc_bold$Phylum == "Arthropoda" & d2_uc_bold$ID != "Heteropoda venatoria", 
                "prey", "non-diet"
         )))

#sort into categories for ncbi:
d2_uc_ncbi$taxonomy <- ifelse(
  d2_uc_ncbi$ID == "Sparassidae" | d2_uc_ncbi$ID == "Heteropoda venatoria", "predator",
  ifelse(d2_uc_ncbi$Phylum == "Arthropoda" & d2_uc_ncbi$ID != "Sparassidae" & d2_uc_ncbi$ID != "Heteropoda venatoria", 
         "prey", "non-diet"
  ))

#this is an anti-join to subset from ALL MEGAN hits for those that aren't within
#diet categories, but which still got assignments in MEGAN
d2_uc_nond <- d2_uc_all %>%
  anti_join(d2_uc_ncbi, by = "ASV")
#this gives these all the category of "non-diet" to distinguish from those that didn't
#get any taxonomic assignment at all. 
d2_uc_nond$taxonomy <- d2_uc_nond$Category

#thus, the taxonomy variable has 5 levels: predator, prey, non-diet, non-hit (which
#we will assign below after merging with full ASV table), and unknown
#subset only the variables of interest from these two dataframes before merging
d2_uc_bold_id <- d2_uc_bold %>%
  dplyr::select(ASV, ID, Order, taxonomy)

d2_uc_ncbi_id <- d2_uc_ncbi %>%
  dplyr::select(ASV, ID, Order, taxonomy)

#join them together by ASV and taxonomy
d2_uc_id_both <- d2_uc_bold_id %>%  
  full_join(d2_uc_ncbi_id, by = c("ASV", "taxonomy"))

#join these both again with the non-diet hits
d2_uc_id_all <- d2_uc_id_both %>%
  full_join(d2_uc_nond, by = c("ASV", "taxonomy"))

d2_uc_id_all <- d2_uc_id_all %>%
  rename(ID_bold = ID.x,
         Order_bold = Order.x,
         ID_ncbi = ID.y,
         Order_ncbi = Order.y,
         ID_nondiet = ID,
         Order_nondiet = Order)

#this binds them all to the community matrix for analyses
d2_uc_id_tab <- d2_uc %>%
  left_join(d2_uc_id_all, by = "ASV")

#set NA taxonomies from join with "no hit" since they didn't match to any
#taxonomic assignments within our prey, predator, or non-prey categories
d2_uc_id_tab$taxonomy <- replace_na(d2_uc_id_tab$taxonomy, "no hit")

#write the taxonomies to a file for use in the community dissimilarity scripts script
d2_uc_taxonomies <- d2_uc_id_tab %>%
  dplyr::select(ASV, ID_bold, Order_bold, ID_ncbi, Order_ncbi, ID_nondiet, Order_nondiet, taxonomy)
write.csv(d2_uc_taxonomies, here("data", 
                                 "outputs",
                                 "taxonomic_data",
                                 "d2_uc_tax_ass.csv"))

#DADA2 CLEAN##
#import both NCBI and BOLD taxonomies
d2_c_ncbi <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                           "MEGAN", 
                           "dada2_clean",
                           "prey", 
                           "dada2_c_prey_ncbi_taxa.csv"))
#this is everything that got a taxonomic assignment through MEGAN
d2_c_all <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                          "MEGAN", 
                          "dada2_clean",
                           "prey", 
                          "dada2_c_prey_ALL.csv"))

d2_c_bold <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                           "BOLD", 
                           "dada2_c", 
                            "prey", 
                           "dada2_c_prey_taxa_bold.csv"))

#Sort by "predator", "prey", and "non-diet" before merging into one 
#dataframe for assigning to the abundance table!
#this following ifelse set will depend on the taxonomy of the set of samples
#and for this one, these are the categories that seemed to be appropriate based
#on the taxonomy list after looking at it
#sort into categories for bold:
d2_c_bold$taxonomy <- ifelse(
  d2_c_bold$ID == "Heteropoda venatoria", "predator",
  ifelse(d2_c_bold$Kingdom == "Fungi", "non-diet", 
         ifelse(d2_c_bold$Phylum == "Arthropoda" & d2_c_bold$ID != "Heteropoda venatoria", 
                "prey", "non-diet"
         )))

#sort into categories for ncbi:
d2_c_ncbi$taxonomy <- ifelse(
  d2_c_ncbi$ID == "Sparassidae" | d2_c_ncbi$ID == "Heteropoda venatoria", "predator",
  ifelse(d2_c_ncbi$Phylum == "Arthropoda" & d2_c_ncbi$ID != "Heteropoda venatoria" & d2_c_ncbi$ID != "Sparassidae", 
         "prey", "non-diet"
  ))

#this is an anti-join to subset from ALL MEGAN hits for those that aren't within
#diet categories, but which still got assignments in MEGAN
d2_c_nond <- d2_c_all %>%
  anti_join(d2_c_ncbi, by = "ASV")
#this gives these all the category of "non-diet" to distinguish from those that didn't
#get any taxonomic assignment at all. 
d2_c_nond$taxonomy <- d2_c_nond$Category

#thus, the taxonomy variable has 5 levels: predator, prey, non-diet, non-hit (which
#we will assign below after merging with full ASV table), and unknown
#subset only the variables of interest from these two dataframes before merging
d2_c_bold_id <- d2_c_bold %>%
  dplyr::select(ASV, ID, Order, taxonomy)

d2_c_ncbi_id <- d2_c_ncbi %>%
  dplyr::select(ASV, ID, Order, taxonomy)

#join them together by ASV and taxonomy
d2_c_id_both <- d2_c_bold_id %>%  
  full_join(d2_c_ncbi_id, by = c("ASV", "taxonomy"))

#join these both again with the non-diet hits
d2_c_id_all <- d2_c_id_both %>%
  full_join(d2_c_nond, by = c("ASV", "taxonomy"))

d2_c_id_all <- d2_c_id_all %>%
  rename(ID_bold = ID.x,
         Order_bold = Order.x,
         ID_ncbi = ID.y,
         Order_ncbi = Order.y,
         ID_nondiet = ID)

#this binds them all to the community matrix for analyses
d2_c_id_tab <- d2_c %>%
  left_join(d2_c_id_all, by = "ASV")

#set NA taxonomies from join with "no hit" since they didn't match to any
#taxonomic assignments within our prey, predator, or non-prey categories
d2_c_id_tab$taxonomy <- replace_na(d2_c_id_tab$taxonomy, "no hit")

#write the taxonomies to a file for use in the community dissimilarity scripts script
d2_c_taxonomies <- d2_c_id_tab %>%
  dplyr::select(ASV, ID_bold, Order_bold, ID_ncbi, Order_ncbi, ID_nondiet, taxonomy)
write.csv(d2_c_taxonomies, here("data", 
                                 "outputs",
                                 "taxonomic_data",
                                "d2_c_tax_ass.csv"))

#UNOISE UNCLEAN##
#import both NCBI and BOLD taxonomies
u3_uc_ncbi <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                            "MEGAN", 
                            "unoise_unclean",
                           "unoise_uc_ncbi_taxa.csv"))
u3_uc_bold <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                            "BOLD", 
                            "usearch_uc", 
                           "unoise_uc_bold_taxa.csv"))
u3_uc_bold <- rename(u3_uc_bold, "ASV" = "Query.ID")

#Sort by "predator", "prey", and "non-diet" before merging into one 
#dataframe for assigning to the abundance table!
#this following ifelse set will depend on the taxonomy of the set of samples
#and for this one, these are the categories that seemed to be appropriate based
#on the taxonomy list after looking at it
#sort into categories for bold:
u3_uc_bold$taxonomy <- ifelse(
  u3_uc_bold$ID == "Heteropoda venatoria", "predator",
  ifelse(u3_uc_bold$Kingdom == "Fungi" | u3_uc_bold$Class == "Mammalia", "non-diet", 
         ifelse(u3_uc_bold$Phylum == "Arthropoda" | u3_uc_bold$Class == "Reptilia" & u3_uc_bold$ID != "Heteropoda venatoria", 
                "prey", "non-diet"
         )))

#sort into categories for ncbi:
u3_uc_ncbi$taxonomy <- u3_uc_ncbi$Category
  
#  ifelse(
#  d2_c_ncbi$ID == "Sparassidae", "predator",
#  ifelse(d2_c_ncbi$Phylum == "Arthropoda" & d2_c_ncbi$ID != "Heteropoda venatoria", 
#         "prey", "non-diet"
#  ))

#thus, the taxonomy variable has 5 levels: predator, prey, non-diet, non-hit (which
#we will assign below after merging with full ASV table), and unknown
#subset only the variables of interest from these two dataframes before merging
u3_uc_bold_id <- u3_uc_bold %>%
  dplyr::select(ASV, ID, Order, taxonomy)

u3_uc_ncbi_id <- u3_uc_ncbi %>%
  dplyr::select(ASV, ID, Order, taxonomy)

#join them together by ASV and taxonomy
u3_uc_id_all <- u3_uc_bold_id %>%  
  full_join(u3_uc_ncbi_id, by = c("ASV", "taxonomy"))

u3_uc_id_all <- u3_uc_id_all %>%
  rename(ID_bold = ID.x,
         Order_bold = Order.x,
         ID_ncbi = ID.y,
         Order_ncbi = Order.y)

#this binds them all to the community matrix for analyses
u3_uc_id_tab <- u3_uc %>%
  left_join(u3_uc_id_all, by = "ASV")

#set NA taxonomies from join with "no hit" since they didn't match to any
#taxonomic assignments within our prey, predator, or non-prey categories
u3_uc_id_tab$taxonomy <- replace_na(u3_uc_id_tab$taxonomy, "no hit")

#write the taxonomies to a file for use in the community dissimilarity scripts script
u3_uc_taxonomies <- u3_uc_id_tab %>%
  dplyr::select(ASV, ID_bold, Order_bold, ID_ncbi, Order_ncbi, taxonomy)
write.csv(u3_uc_taxonomies, here("data", 
                                 "outputs",
                                 "taxonomic_data",
                                 "u3_uc_tax_ass.csv"))

#UNOISE CLEAN##
#import both NCBI and BOLD taxonomies
u3_c_ncbi <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                           "MEGAN",
                           "unoise_clean",
                            "prey",
                           "unoise_c_prey_ALL_ncbi_taxa.csv"))

u3_c_bold <- read.csv(here("data",
                            "data_raw",
                            "3_taxonomies",
                           "BOLD", 
                           "usearch_c", 
                            "prey", "unoise3_c_prey_bold_taxa.csv"))
u3_c_bold <- rename(u3_c_bold, "ASV" = "Query.ID")

#Sort by "predator", "prey", and "non-diet" before merging into one 
#dataframe for assigning to the abundance table!
#this following ifelse set will depend on the taxonomy of the set of samples
#and for this one, these are the categories that seemed to be appropriate based
#on the taxonomy list after looking at it
#sort into categories for bold:
u3_c_bold$taxonomy <- ifelse(
  u3_c_bold$ID == "Heteropoda venatoria", "predator",
  ifelse(u3_c_bold$Kingdom == "Fungi" | u3_c_bold$Class == "Mammalia", "non-diet", 
         ifelse(u3_c_bold$Phylum == "Arthropoda" & u3_c_bold$ID != "Heteropoda venatoria", 
                "prey", "non-diet"
         )))

#sort into categories for ncbi:
u3_c_ncbi$taxonomy <- u3_c_ncbi$Category

#  ifelse(
#  d2_c_ncbi$ID == "Sparassidae", "predator",
#  ifelse(d2_c_ncbi$Phylum == "Arthropoda" & d2_c_ncbi$ID != "Heteropoda venatoria", 
#         "prey", "non-diet"
#  ))

#thus, the taxonomy variable has 5 levels: predator, prey, non-diet, non-hit (which
#we will assign below after merging with full ASV table), and unknown
#subset only the variables of interest from these two dataframes before merging
u3_c_bold_id <- u3_c_bold %>%
  dplyr::select(ASV, ID, Order, taxonomy)

u3_c_ncbi_id <- u3_c_ncbi %>%
  dplyr::select(ASV, ID, Order, taxonomy)

#join them together by ASV and taxonomy
u3_c_id_all <- u3_c_bold_id %>%  
  full_join(u3_c_ncbi_id, by = c("ASV", "taxonomy"))

u3_c_id_all <- u3_c_id_all %>%
  rename(ID_bold = ID.x,
         Order_bold = Order.x,
         ID_ncbi = ID.y,
         Order_ncbi = Order.y)

#this binds them all to the community matrix for analyses
u3_c_id_tab <- u3_c %>%
  left_join(u3_c_id_all, by = "ASV")

#set NA taxonomies from join with "no hit" since they didn't match to any
#taxonomic assignments within our prey, predator, or non-prey categories
u3_c_id_tab$taxonomy <- replace_na(u3_c_id_tab$taxonomy, "no hit")

#write the taxonomies to a file for use in the community dissimilarity scripts script
u3_c_taxonomies <- u3_c_id_tab %>%
  dplyr::select(ASV, ID_bold, Order_bold, ID_ncbi, Order_ncbi, taxonomy)

write.csv(u3_c_taxonomies, 
          here("data", 
               "outputs",
               "taxonomic_data",
               "u3_c_tax_ass.csv"))
```

```{r, include=FALSE}
#3. total number of prey ASVs for each pipeline ####
#summarise each dataframe by sample (which also gives ASVs in the ASV category)
#grouped by taxonomy, giving both a total ASV count in each category AND
#a per sample value for each category (no hit, non-diet, predator, prey, unknown)
d2_uc_ASVs <- d2_uc_id_tab %>%
  group_by(taxonomy) %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, ASVs_d2_uc, ASV:QC1, factor_key=TRUE) %>%
  dplyr::select(taxonomy, sample, ASVs_d2_uc)
  
d2_c_ASVs <- d2_c_id_tab %>%
  group_by(taxonomy) %>%
  summarise_all(~sum(. !=0)) %>%
  gather(sample, ASVs_d2_c, ASV:HEV89, factor_key = TRUE) %>%
  dplyr::select(taxonomy, sample, ASVs_d2_c)

u3_uc_ASVs <- u3_uc_id_tab %>%
  group_by(taxonomy) %>%
  summarise_all(~sum(. !=0)) %>%
  gather(sample, ASVs_u3_uc, ASV:QC1, factor_key = TRUE) %>%
  dplyr::select(taxonomy, sample, ASVs_u3_uc)

u3_c_ASVs <- u3_c_id_tab %>%
  group_by(taxonomy) %>%
  summarise_all(~sum(. !=0)) %>%
  gather(sample, ASVs_u3_c, ASV:HEV99, factor_key = TRUE) %>%
  dplyr::select(taxonomy, sample, ASVs_u3_c)

#join these four together
taxa_ASVs <- d2_uc_ASVs %>%
  full_join(d2_c_ASVs, by = c("taxonomy", "sample")) %>%
  full_join(u3_uc_ASVs, by = c("taxonomy", "sample")) %>%
  full_join(u3_c_ASVs, by = c("taxonomy", "sample"))

taxa_ASVs[is.na(taxa_ASVs)] <- 0

#filter out controls for analyses of by sample reads
taxa_ASVs_samples <- taxa_ASVs %>%
  filter(!sample %in% c("ASV", "CL1", "NEG", "CL4", "QC1"))

#make this dataframe longer for analysis with lme4
taxa_ASVs_samples_long <- taxa_ASVs_samples %>%
  gather(pipeline, ASVs, ASVs_d2_uc:ASVs_u3_c)

#grouped lme by sample to see if there are differences across pipelines

#select only prey ASVs
taxa_ASVs_prey <- taxa_ASVs_samples_long %>%
  filter(taxonomy == "prey")

#spllit by field and lab by joining with metadata first
taxa_ASVs_prey <- taxa_ASVs_prey %>%
  left_join(metadata, by = "sample")

#create binary sterilized factor
taxa_ASVs_prey$Ster <- ifelse(taxa_ASVs_prey$Sterilized == "NS", 0, 1)
taxa_ASVs_prey$Ster <- as.factor(as.character(taxa_ASVs_prey$Ster))


#then create a model fitting the number of ASVs to pipeline grouped by sample
lme_prey_ASVs <- glmmTMB(ASVs ~ pipeline + (1|sample),
                 data = taxa_ASVs_prey,
                 family = "genpois",
                 REML = FALSE)

lme_prey_ASVs_null <- glmmTMB(ASVs ~ 1 + (1|sample),
                      data = taxa_ASVs_prey,
                      family = "genpois",
                      REML = FALSE)

#compare by AIC values
AICc(lme_prey_ASVs, lme_prey_ASVs_null)

lme_prey_ASVs <- glmmTMB(ASVs ~ pipeline + (1|sample),
                 data = taxa_ASVs_prey,
                 family = "genpois")

model.emm_preyASV <- emmeans(lme_prey_ASVs, "pipeline")
pairs(model.emm_preyASV)

x_preyASV <- residuals(lme_prey_ASVs)
plot(x_preyASV)
#residuals look relatively normal
summary(lme_prey_ASVs)
plot(residuals(lme_prey_ASVs)) #residuals look fairly homoskedastic
plot(allEffects(lme_prey_ASVs)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
simulationOutput_preyASV <- simulateResiduals(fittedModel = lme_prey_ASVs) 
preyASVfit <- plot(simulationOutput_preyASV, asFactor=TRUE) #these look good
preyASVzi <- testZeroInflation(simulationOutput_preyASV) #not zero inflated
preyASVod <- testDispersion(simulationOutput_preyASV) #not overdispersed

#boxplot visualization
prey_ASV_graph <- ggplot(taxa_ASVs_prey, aes(x = pipeline, y = ASVs)) +
         geom_boxplot() +
         labs(x = "Pipeline", y = "Prey ASVs per sample", 
              title = "Field: Total prey ASVs assigned to each sample") +
         theme_bw() 

```

```{r, include=FALSE}
#4. total prey ASV read abundance ####
#add up the total number of reads by group in each sample for each pipeline
d2_uc_reads <- d2_uc_id_tab %>%
  dplyr::select(-ID_bold, -Order_bold, -ID_ncbi, -Order_ncbi, -ID_nondiet, -Order_nondiet, -Category) %>%
  group_by(ASV) %>%
  gather(sample, reads, CL1:QC1, factor_key = TRUE) %>%
  group_by(sample, taxonomy) %>%
  summarise(reads_d2_uc = sum(reads))

d2_c_reads <- d2_c_id_tab %>%
  dplyr::select(-ID_bold, -Order_bold, -ID_ncbi, -Order_ncbi, -ID_nondiet, -Category) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV100:HEV89, factor_key=TRUE) %>%
  group_by(sample, taxonomy) %>%
  summarise(reads_d2_c = sum(reads))

u3_uc_reads <- u3_uc_id_tab %>%
  dplyr::select(-ID_bold, -Order_bold, -ID_ncbi, -Order_ncbi) %>%
  group_by(ASV) %>%
  gather(sample, reads, CL1:QC1, factor_key = TRUE) %>%
  group_by(sample, taxonomy) %>%
  summarise(reads_u3_uc = sum(reads))

u3_c_reads <- u3_c_id_tab %>%
  dplyr::select(-ID_bold, -Order_bold, -ID_ncbi, -Order_ncbi) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV07:HEV99, factor_key=TRUE) %>%
  group_by(sample, taxonomy) %>%
  summarise(reads_u3_c = sum(reads))
  
#join these all together now
taxa_reads <- d2_uc_reads %>%
  full_join(d2_c_reads, by = c("taxonomy", "sample")) %>%
  full_join(u3_uc_reads, by = c("taxonomy", "sample")) %>%
  full_join(u3_c_reads, by = c("taxonomy", "sample"))

taxa_reads[is.na(taxa_reads)] <- 0

#filter out controls for analyses of by sample reads
taxa_reads_samples <- taxa_reads %>%
  filter(!sample %in% c("CL1", "NEG", "CL4", "QC1"))

#make this dataframe longer for analysis with lme4
taxa_reads_samples_long <- taxa_reads_samples %>%
  gather(pipeline, reads, reads_d2_uc:reads_u3_c)

#select only prey reads
taxa_reads_prey <- taxa_reads_samples_long %>%
  filter(taxonomy == "prey")

taxa_reads_prey <- taxa_reads_prey %>%
  left_join(metadata, by = "sample")

#prey reads
#then create a model fitting the number of reads to pipeline grouped by sample
read_mod <- glmmTMB(reads ~ pipeline + (1|sample),
                 data = taxa_reads_prey,
                 family = "genpois",
                 REML = FALSE)

read_mod_null <- glmmTMB(reads ~ 1 + (1|sample),
                      data = taxa_reads_prey,
                      family = "genpois",
                      REML = FALSE)

#compare models with AIC
AICc(read_mod, read_mod_null)
#models 2 and 3 are lowest, with 3 being the most parsimonious, which includes 
#only pipeline. 
read_mod <- glmmTMB(reads ~ pipeline + (1|sample),
                       data = taxa_reads_prey,
                       family = "genpois")
model.emm_preyreads <- emmeans(read_mod, "pipeline")
pairs(model.emm_preyreads)

x_read <- residuals(read_mod)
plot(x_read)
#residuals look relatively normal
summary(read_mod)
plot(residuals(read_mod)) #residuals look fairly homoskedastic
plot(allEffects(read_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
simulationOutput_preyreads <- simulateResiduals(fittedModel = read_mod) 
preyreadsfit <- plot(simulationOutput_preyreads, asFactor=TRUE) #these look good
preyreadszi <- testZeroInflation(simulationOutput_preyreads) #looks good
preyreadsod <- testDispersion(simulationOutput_preyreads) #not overdispersed

#boxplot visualization
prey_reads_graph <- ggplot(taxa_reads_prey, aes(x = pipeline, y = reads)) +
  geom_boxplot() + scale_y_log10() +
  labs(x = "Pipeline", y = "Prey reads per sample", 
       title = "Field: Total number of prey reads per ASV per sample") +
  theme_bw() 

```

```{r, include = FALSE}
#5. proportion of prey ASVs to total ASVs (number of ASVs) ####
#I'm using a general poisson with an offset to model proportions.
#the tot_oth column created here along with this dataframe can be 
#used to look at prey/other ratio in Step 7
#will be using d2_uc_ASVs, d2_c_ASVs, u3_uc_ASVs, and u3_c_ASVs here
d2_uc_totals <- d2_uc_ASVs %>%
  spread(taxonomy, ASVs_d2_uc) %>%
  mutate(tot_oth = (predator + `no hit` + `non-diet`),
         tot = (predator + `no hit` + `non-diet` + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
d2_uc_totals$pipeline <- "d2_uc"

d2_c_totals <- d2_c_ASVs %>%
  spread(taxonomy, ASVs_d2_c) %>%
  mutate(tot_oth = (predator + `non-diet`),
         tot = (predator + `non-diet` + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
d2_c_totals$pipeline <- "d2_c"

u3_uc_totals <- u3_uc_ASVs %>%
  spread(taxonomy, ASVs_u3_uc) %>%
  mutate(tot_oth = (predator + `no hit` + `non-diet`),
         tot = (predator + `no hit` + `non-diet` + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
u3_uc_totals$pipeline <- "u3_uc"

u3_c_totals <- u3_c_ASVs %>%
  spread(taxonomy, ASVs_u3_c) %>%
  mutate(tot_oth = (predator + `non-diet`),
         tot = (predator + `non-diet` + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
u3_c_totals$pipeline <- "u3_c"

#join these all together now
ASV_totals <- bind_rows(d2_uc_totals, d2_c_totals,
                        u3_uc_totals, u3_c_totals)

#filter out controls for analyses of by sample ASV
ASV_totals_samples <- ASV_totals %>%
  filter(!sample %in% c("ASV", "CL1", "NEG", "CL4", "QC1"))

#total ASVS
ASV_totals %>%
  filter(sample == "ASV") 

#ASV_totals_samples$tot_scaled <- scale(ASV_totals_samples$tot)[, 1]
ASV_totals_samples <- ASV_totals_samples[which(ASV_totals_samples$tot > 0),]

ASV_totals_samples <- ASV_totals_samples %>%
  left_join(metadata, by = "sample")

ASV_totals_samples$Ster <- as.factor(ifelse(ASV_totals_samples$Sterilized == "NS", 0, 1))

#FIELD
#then create a model fitting the number of ASVs to pipeline grouped by sample
prey_prop_mod <- glmmTMB(prey ~ pipeline + (1|sample),
                          data = ASV_totals_samples,
                          family = "genpois",
                         offset = log(tot),
                         REML = FALSE)

#the null model where pipeline does not matter
prey_prop_mod_null <- glmmTMB(prey ~ 1 + (1|sample),
                              data = ASV_totals_samples,
                              family = "genpois",
                              offset = log(tot),
                              REML= FALSE)
#compare these with AIC
AICc(prey_prop_mod, prey_prop_mod_null)
#model 3 is *just* over two AIC values lower than model 2, has the both the lowest
#AIC and the most parsimonious structure
prey_prop_mod <- glmmTMB(prey ~ pipeline + (1|sample),
                            data = ASV_totals_samples,
                            family = "genpois",
                            offset = log(tot))

model.emm_preyprop <- emmeans(prey_prop_mod, "pipeline")
pairs(model.emm_preyprop)
#Cleaning increased proportion of prey ASVs for both DADA2 and UNOISE3
#The uncleaned datasets do not have significantly different numbers of
#prey ASVs, though DADA2 clean has more than UNOISE clean (probs because
#of using DADA2 for BBSPLIT, TBH). 

x_prop <- residuals(prey_prop_mod)
plot(x_prop)
#residuals look relatively normal
plot(residuals(prey_prop_mod)) #residuals look fairly homoskedastic
plot(allEffects(prey_prop_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
simulationOutput_preyprop <- simulateResiduals(fittedModel = prey_prop_mod) 
preypropfit <- plot(simulationOutput_preyprop, asFactor=TRUE) #these look weird now... with offset
preypropzi <- testZeroInflation(simulationOutput_preyprop) #what is the opposite of zero inflation??
preypropod <- testDispersion(simulationOutput_preyprop) #not overdispersed

#boxplot visualization
prey_prop_graph <- ggplot(ASV_totals_samples, aes(x = pipeline, y = prey/tot)) +
  geom_boxplot() +
  labs(x = "Pipeline", y = "Prey ASV percentage by sample", title = "Percent of prey ASVs per sample") +
  theme_bw() 
```

```{r, include = FALSE}
#6. proportion of prey reads to total ASV reads (read abundance) ####
#will be using d2_uc_reads, d2_c_reads, u3_uc_reads, and u3_c_reads here
#as in the ASV steps above, i'm creating both a total reads and a total
#non-prey reads cateogry here that we can use in step 8 below
d2_uc_read_tot <- d2_uc_reads %>%
  spread(taxonomy, reads_d2_uc) %>%
  mutate(tot_oth = (predator + `no hit` + `non-diet`),
         tot = (predator + `no hit` + `non-diet` + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
d2_uc_read_tot$pipeline <- "d2_uc"

d2_c_read_tot <- d2_c_reads %>%
  spread(taxonomy, reads_d2_c) %>%
  mutate(tot_oth = (predator + `non-diet` ),
         tot = (predator + `non-diet`  + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
d2_c_read_tot$pipeline <- "d2_c"

u3_uc_read_tot <- u3_uc_reads %>%
  spread(taxonomy, reads_u3_uc) %>%
  mutate(tot_oth = (predator + `no hit` + `non-diet` ),
         tot = (predator + `no hit` + `non-diet`  + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
u3_uc_read_tot$pipeline <- "u3_uc"

u3_c_read_tot <- u3_c_reads %>%
  spread(taxonomy, reads_u3_c) %>%
  mutate(tot_oth = (predator + `non-diet` ),
         tot = (predator + `non-diet`  + prey)) %>%
  dplyr::select(sample, prey, tot_oth, tot)
u3_c_read_tot$pipeline <- "u3_c"


#join these all together now
read_totals <- bind_rows(d2_uc_read_tot, d2_c_read_tot,
                        u3_uc_read_tot, u3_c_read_tot)

#filter out controls for analyses of by sample ASV
read_totals_samples <- read_totals %>%
  filter(!sample %in% c("CL1", "CL4", "QC1", "NEG"))

read_totals_samples <- read_totals_samples %>%
  left_join(metadata, by = "sample") %>%
  filter(tot > 0)


#then create a model fitting the number of ASVs to pipeline grouped by sample
prey_rprop_mod <- glmmTMB(prey ~ pipeline + (1|sample),
                         data = read_totals_samples,
                         family = "genpois",
                         ziformula = ~1,
                         offset = log(tot),
                         REML =FALSE)


prey_rprop_mod_null <- glmmTMB(prey ~ 1 + (1|sample),
                              data = read_totals_samples,
                              family = "genpois",
                              offset = log(tot),
                              REML = FALSE)

AICc(prey_rprop_mod, prey_rprop_mod_null)


x_rprop <- residuals(prey_rprop_mod)
plot(x_rprop)
#residuals look relatively normal
plot(residuals(prey_rprop_mod)) #residuals look fairly homoskedastic
#plot(allEffects(prey_rprop_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
simulationOutput_preyrprop <- simulateResiduals(fittedModel = prey_rprop_mod) 
preyrpropfit <- plot(simulationOutput_preyrprop, asFactor=TRUE) #haha what is with the residuals?
preyrpropzi <- testZeroInflation(simulationOutput_preyrprop) #look fine
preyrpropod <- testDispersion(simulationOutput_preyrprop) #not overdispersed

#boxplot visualization
prey_rprop_graph <- ggplot(read_totals_samples, aes(x = pipeline, y = prey/tot)) +
  geom_boxplot() +
  labs(x = "Pipeline", y = "Prey read proportion by sample", 
       title = "Field: Perecent of prey reads in each sample") +
  theme_bw() 

```


```{r, include = FALSE}
###a. consider here sequencing depth? Ask Austen
#7. Prey/OTHER ASV ratios ####
#the tot_oth column created in ASV_totals_samples 
#can be used in this analysis
#need to delete those for which total other is equal to zero
#ASV_totals_samples_ratio <- ASV_totals_samples[which(ASV_totals_samples$tot_oth > 0),]
#then create a model fitting the number of ASVs to pipeline grouped by sample
#prey_ratio_mod <- glmmTMB(prey ~ pipeline + (1|sample),
#                         data = ASV_totals_samples_ratio,
#                         family = "genpois",
#                         ziformula = ~1,
#                         offset = log(tot_oth))
#the null model where pipeline does not matter
#prey_ratio_mod_null <- glmmTMB(prey ~ 1 + (1|sample),
#                              data = ASV_totals_samples_ratio,
#                              family = "genpois",
#                              ziformula = ~1,
#                              offset = log(tot_oth))

#model.emm <- emmeans(prey_ratio_mod, "pipeline")
#pairs(model.emm)
#cleaning increased the proportion of prey ASVs for
#both dada2 and unoise
#dada2 uncleaned had higher prey ASV ratio than unoise uncleaned
#the cleaned datasets do not vary in their prey/other ASV ratio

#x_rat <- residuals(prey_ratio_mod)
#plotNormalHistogram(x_rat)
#residuals look relatively normal
#plot(residuals(prey_ratio_mod)) #residuals look fairly homoskedastic
#plot(allEffects(prey_ratio_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
#simulationOutput <- simulateResiduals(fittedModel = prey_ratio_mod) 
#WARNING: THESE BREAK R RIGHT NOW
#plot(simulationOutput, asFactor=TRUE) #these look good
#testZeroInflation(simulationOutput) #these are zero inflated
#testDispersion(simulationOutput) #not overdispersed
#hist(ASV_totals_samples$prey)
#boxplot visualization
#ggplot(ASV_totals_samples_ratio, aes(x = pipeline, y = prey/tot_oth)) +
#  geom_boxplot() +
#  labs(x = "Pipeline", y = "Prey/Other ASV ratio per sample") +
#  theme_bw()
#8. predator/prey read abundance ####
#read_totals_samples using the tot_oth category
#first, delete columns with zero in the tot_oth category
#read_totals_samples_ratio <- read_totals_samples[which(read_totals_samples$tot_oth > 0),]

#then create a model fitting the number of ASVs to pipeline grouped by sample
#prey_rratio_mod <- glmmTMB(prey ~ pipeline + (1|sample),
#                          data = read_totals_samples_ratio,
#                          family = "genpois",
#                          ziformula = ~1,
#                          offset = log(tot_oth))
#the null model where pipeline does not matter
#prey_rratio_mod_null <- glmmTMB(prey ~ 1 + (1|sample),
#                               data = read_totals_samples_ratio,
#                               family = "genpois",
#                               ziformula = ~1,
#                               offset = log(tot_oth))

#model.emm <- emmeans(prey_rratio_mod, "pipeline")
#pairs(model.emm)
#cleaning significantly increased the ratio of prey to other reads
#for both pipelines
#there is no significant difference in prey read ratios between either
#cleaned or uncleaned datasets

#x_rrat <- residuals(prey_rratio_mod)
#plotNormalHistogram(x_rrat)
#residuals look relatively normal
#plot(residuals(prey_rratio_mod)) #residuals look fairly homoskedastic
#plot(allEffects(prey_rratio_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
#simulationOutput <- simulateResiduals(fittedModel = prey_rratio_mod) 
#plot(simulationOutput, asFactor=TRUE) #these look good
#testZeroInflation(simulationOutput) #these are zero inflated...
#testDispersion(simulationOutput) #not overdispersed

#boxplot visualization
#ggplot(read_totals_samples_ratio, aes(x = pipeline, y = prey/tot_oth)) +
#  geom_boxplot() +
#  labs(x = "Pipeline", y = "Prey/Other read ratio per sample") +
#  theme_bw()

```


```{r, include = FALSE}
#9. amount of known diet item for lab-fed (ASVs) ####
#subset samples of interest from dataframe (lab fed) using these dataframes:
#d2_uc_id_tab
#d2_c_id_tab
#u3_uc_id_tab
#d2_ASVct <- d2_uc %>%
#  summarise_all(~sum(. != 0)) %>%
#  gather(sample, ASVs_d2uc, ASV:QC1, factor_key = TRUE) 
#u3_c_id_tab

metadata <- read.csv(here("data", 
                          "data_raw",
                          "2_sample_data",
                          "Sample_Metadata.csv"))

lab <- as.character(metadata$sample[which(metadata$Source == "LAB")])
 
d2_uc_lab <- d2_uc_id_tab %>%
  dplyr::select(all_of(lab), ID_bold, ID_ncbi, ID_nondiet) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi, -ID_nondiet) %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, prey_d2uc, HEV07:HEV29, factor_key=TRUE)

d2_c_lab <- d2_c_id_tab %>%
  dplyr::select(all_of(lab), ID_bold, ID_ncbi, ID_nondiet) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi, -ID_nondiet) %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, prey_d2c, HEV07:HEV29, factor_key=TRUE)

u3_uc_lab <- u3_uc_id_tab %>%
  dplyr::select(all_of(lab), ID_bold, ID_ncbi) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi) %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, prey_u3uc, HEV07:HEV29, factor_key=TRUE)

u3_c_lab <- u3_c_id_tab %>%
  dplyr::select(all_of(lab), ID_bold, ID_ncbi) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi) %>%
  summarise_all(~sum(. != 0)) %>%
  gather(sample, prey_u3c, HEV07:HEV29, factor_key=TRUE)

#join these two together
known_prey_ASVs <- d2_uc_lab %>%
  full_join(d2_c_lab, by = "sample") %>%
  full_join(u3_uc_lab, by = "sample") %>%
  full_join(u3_c_lab, by = "sample")


#delete those that are zero across all pipelines (as my model is being dumb)
known_prey_ASVs <- known_prey_ASVs %>%
  filter(prey_u3uc > 0)

known_ASVs_long <- known_prey_ASVs %>%
  gather(pipeline, value, prey_d2uc:prey_u3c)
#this model is not working when i group by sample... :'(
#this is a BAD model right now...
#known_ASVs_mod <- glmmTMB(value ~ pipeline,
#                       data = known_ASVs_long,
#                       ziformula = ~1,
#                       family = "genpois")

#known_ASVs_mod_null <- glmmTMB(value ~ 1,
#                            data = known_ASVs_long,
#                            ziformula = ~1,
#                            family = "genpois")

#model.emm <- emmeans(known_ASVs_mod, "pipeline")
#pairs(model.emm)
#ACCORDING TO BAD MODEL:
#the number of ASVs assigned to known prey did not vary
#between cleaned-uncleaned pairs of the same pipeline
#however, the number varies across pipelines, both for clean
#and unclean pairs, with known prey ASVs being higher in
#both dadd2 clean and unclean pipelines

#x_ASVs <- residuals(known_ASVs_mod)
#plotNormalHistogram(x_ASVs)
#residuals look relatively normal
#summary(known_ASVs_mod)
#plot(residuals(known_ASVs_mod)) #residuals look fairly homoskedastic
#plot(allEffects(known_ASVs_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
#simulationOutput <- simulateResiduals(fittedModel = known_ASVs_mod) 
#plot(simulationOutput, asFactor=FALSE) #these look good
#testZeroInflation(simulationOutput) #not zero inflated
#testDispersion(simulationOutput) #not overdispersed
#AICc(known_ASVs_mod, known_ASVs_mod_null) #model with pipeline is better than model without

#and that boxplot here
#ggplot(known_ASVs_long, aes(x = pipeline, y = value)) +
#  geom_boxplot() +
#  labs(x = "Pipeline", y = "Known ASVs per sample") +
#  theme_bw()


#10. amount of knwon diet item for lab-fed (num of reads) ####
d2_uc_rlab <- d2_uc_id_tab %>%
  dplyr::select(all_of(lab), ASV, ID_bold, ID_ncbi, ID_nondiet) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi, -ID_nondiet) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV07:HEV29, factor_key = TRUE) %>%
  group_by(sample) %>%
  summarise(reads_d2_uc = sum(reads))

d2_c_rlab <- d2_c_id_tab %>%
  dplyr::select(all_of(lab), ASV, ID_bold, ID_ncbi, ID_nondiet) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi, -ID_nondiet) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV07:HEV29, factor_key = TRUE) %>%
  group_by(sample) %>%
  summarise(reads_d2_c = sum(reads))

u3_uc_rlab <- u3_uc_id_tab %>%
  dplyr::select(all_of(lab), ASV, ID_bold, ID_ncbi) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV07:HEV29, factor_key = TRUE) %>%
  group_by(sample) %>%
  summarise(reads_u3_uc = sum(reads))

u3_c_rlab <- u3_c_id_tab %>%
  dplyr::select(all_of(lab), ASV, ID_bold, ID_ncbi) %>%
  filter(ID_ncbi == "Acrididae") %>%
  dplyr::select(-ID_bold, -ID_ncbi) %>%
  group_by(ASV) %>%
  gather(sample, reads, HEV07:HEV29, factor_key = TRUE) %>%
  group_by(sample) %>%
  summarise(reads_u3_c = sum(reads))

#join these two together
known_prey_reads <- d2_uc_rlab %>%
  full_join(d2_c_rlab, by = "sample") %>%
  full_join(u3_uc_rlab, by = "sample") %>%
  full_join(u3_c_rlab, by = "sample")

known_reads_long <- known_prey_reads %>%
  gather(pipeline, value, reads_d2_uc:reads_u3_c)

known_reads_long <- known_reads_long %>%
  left_join(metadata, by = "sample")

known_reads_long$Ster <- as.factor(ifelse(known_reads_long$Sterilized == "NS", 0, 1))

#now run the model
known_reads_mod <- glmmTMB(value ~ pipeline + (1|sample),
                          data = known_reads_long,
                          family = "genpois",
                          REML = FALSE)

known_reads_mod_null <- glmmTMB(value ~ 1 + (1|sample),
                               data = known_reads_long,
                               family = "genpois")

AICc(known_reads_mod, known_reads_mod_null)
#model 1 is the best fit based on AIC values.
known_reads_mod <- glmmTMB(value ~ pipeline + (1|sample),
                           data = known_reads_long,
                           family = "genpois")

model.emm_knownprey <- emmeans(known_reads_mod, "pipeline")

pairs(model.emm_knownprey)

x_knownprey <- residuals(known_reads_mod)
plot(x_knownprey)
#residuals look relatively normal
summary(known_reads_mod)
plot(residuals(known_reads_mod)) #eek
plot(allEffects(known_reads_mod)) #some version of this I think would be a good paper figure
#but ideally prettier

#checking other model assumptions here:
simulationOutput_knownprey <- simulateResiduals(fittedModel = known_reads_mod) 
knownpreyfit <- plot(simulationOutput_knownprey, asFactor=FALSE) #these look good
knownpreyzi <- testZeroInflation(simulationOutput_knownprey) #not zero inflated
knownpreyod <- testDispersion(simulationOutput_knownprey) #maybe overdispersed???

#and that boxplot here
known_prey_plot <- ggplot(known_reads_long, aes(x = pipeline, y = value)) +
  geom_boxplot() +
  labs(x = "Pipeline", y = "Known prey reads per sample", title = "Number of known prey reads per sample") +
  theme_bw() 
```


``` {r, include = FALSE, eval = FALSE}
#Intermediate: Phylogenetic trees of prey ASVs ####
#currently I have not included phylogenies from BOLD in this, 
#which... maybe doesn't need to happen? I dont' know sigh
#according to the taxonomy databases, there is ONE ASV of prey
#origin that BOLD matches that MEGAN doesn't ACROSS ALL pipelines
#so I think i'm okay with no BOLD

#SOME PD resources to start:
#ses.pd in the picante package:
#https://rdrr.io/rforge/picante/man/pd.html
#general phylogeny tricks here:
#http://www.phytools.org/eqg/Exercise_3.2/

#I created a meta-tree of both hits from the unclean dada2 and unoise
#pipelines in MEGAN (since cleaning didn't add any diversity, this represents
#the total possible diversity of any pipeline)
#I created a tree at the Order level and at the Family level
#then, MEGAN didn't compute branch lengths, so I did
ord_tree <- read.tree(here("data",
                           "data_raw",
                           "3_taxonomies",
                           "trees",
                           "bilateria_order.tre"))
ord_tree1 <- compute.brlen(ord_tree, method = "Grafen")
ord_tree2 <- di2multi(ord_tree1) #this collapses multichotomies so that branch
#lengths aren't domianted by zeros

#same for family tree
fam_tree <- read.tree(here("data",
                           "data_raw",
                           "3_taxonomies",
                           "trees",
                           "bilateria_family.tre"))
fam_tree1 <- compute.brlen(fam_tree, method = "Grafen")
fam_tree2 <- di2multi(fam_tree1)
fam_tree2$edge.length
#For community data:
#will be using a manipulated and transposed version of each
#pipeline's _ncbi dataframe attached to the community matrix "pipeline"_"c/uc"

#the general direction here is to subset all reads that include
#prey and not anything else within my community matrices
#going to be using the NCBI matches and the basic community matrix
#filtering out everything but prey

#11. Phylogenetic Diversity of Prey ASVs at ORDER LEVEL####
#DADA2 UNCLEAN at ORDER LEVEL##
#need to combine and add all ASV reads across all samples to
#get a meta-ASV count for the entire pipeline
#this following pipe does that
d2_uc_sum <- d2_uc %>%
  dplyr::select(-CL1, -CL4, -QC1) %>% #remove controls
  gather(sample, reads, HEV100:HEV89) %>% #gather by ASV and sample
  group_by(ASV) %>% #group by ASV
  summarise(reads= sum(reads)) %>% #summarise the total reads in each ASV
  filter(reads > 0) #filter only those that are greater than 0

d2_uc_ncbi$ASV <- as.character(d2_uc_ncbi$ASV)
d2_uc_sum$ASV <- as.character(d2_uc_sum$ASV)
d2_uc_phy_tab <- d2_uc_ncbi %>%
  filter(taxonomy == "prey") %>%
  dplyr::select(ASV, ID, Order, Family) %>%
  left_join(d2_uc_sum, by = "ASV") %>%
  dplyr::select(-ASV, -ID) #55 TOTAL

#create an order dataframe first by selecting only order column and
#then deleting everything in the order column that is blank 
d2_uc_phy_tab_ord <- d2_uc_phy_tab %>%
  dplyr::select(-Family) %>%
  na_if("") %>%
  drop_na(Order) #46 observations, so 9 had no order ID

#gather by sample and group by sample and Order to summarise how many are in each order
#(we are removing duplicate orders by combining them here). Then spread back out to a 
#community matrix with samples as the columns and orders in those samples as rows
d2_uc_phy_tab_ord <- d2_uc_phy_tab_ord %>%
  group_by(Order) %>%
  summarise(reads = sum(reads))  #14 ORDERS

#set rownames to ID column, and then remove that column
rownames(d2_uc_phy_tab_ord) <- d2_uc_phy_tab_ord$Order
d2_uc_phy_tab_ord <- d2_uc_phy_tab_ord %>%
  dplyr::select(-Order)

#transpose for phylogenetic analyses
d2_uc_phy_tab_ord_t <- as.data.frame(t(d2_uc_phy_tab_ord))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_d2uc_ord <- picante::pd(d2_uc_phy_tab_ord_t, ord_tree2, include.root=TRUE)
pd_d2uc_ord$pipeline <- "d2_uc"
#UNOISE 3 UC
u3_uc_sum <- u3_uc %>%
  dplyr::select(-CL1, -CL4, -QC1, -NEG) %>% #remove controls
  gather(sample, reads, HEV15:HEV83) %>% #gather by ASV and sample
  group_by(ASV) %>% #group by ASV
  summarise(reads= sum(reads)) %>% #summarise the total reads in each ASV
  filter(reads > 0) #filter only those that are greater than 0

u3_uc_ncbi$ASV <- as.character(u3_uc_ncbi$ASV)
u3_uc_sum$ASV <- as.character(u3_uc_sum$ASV)
u3_uc_phy_tab <- u3_uc_ncbi %>%
  filter(taxonomy == "prey") %>%
  dplyr::select(ASV, ID, Order, Family) %>%
  left_join(u3_uc_sum, by = "ASV") %>%
  dplyr::select(-ASV, -ID) #52 TOTAL

#create an order dataframe first by selecting only order column and
#then deleting everything in the order column that is blank 
u3_uc_phy_tab_ord <- u3_uc_phy_tab %>%
  dplyr::select(-Family) %>%
  na_if("") %>%
  drop_na(Order) #43 observations

#gather by sample and group by sample and Order to summarise how many are in each order
#(we are removing duplicate orders by combining them here). Then spread back out to a 
#community matrix with samples as the columns and orders in those samples as rows
u3_uc_phy_tab_ord <- u3_uc_phy_tab_ord %>%
  group_by(Order) %>%
  summarise(reads = sum(reads, na.rm = TRUE))  #13 ORDERS

#set rownames to ID column, and then remove that column
rownames(u3_uc_phy_tab_ord) <- u3_uc_phy_tab_ord$Order
u3_uc_phy_tab_ord <- u3_uc_phy_tab_ord %>%
  dplyr::select(-Order)

#transpose for phylogenetic analyses
u3_uc_phy_tab_ord_t <- as.data.frame(t(u3_uc_phy_tab_ord))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_u3uc_ord <- picante::pd(u3_uc_phy_tab_ord_t, ord_tree2, include.root=TRUE)
pd_u3uc_ord$pipeline <- "u3_uc"
#DADA2 CLEAN ##
#need to combine and add all ASV reads across all samples to
#get a meta-ASV count for the entire pipeline
#this following pipe does that
d2_c_sum <- d2_c %>%
  gather(sample, reads, HEV100:HEV89) %>% #gather by ASV and sample
  group_by(ASV) %>% #group by ASV
  summarise(reads= sum(reads)) %>% #summarise the total reads in each ASV
  filter(reads > 0) #filter only those that are greater than 0

d2_c_ncbi$ASV <- as.character(d2_c_ncbi$ASV)
d2_c_sum$ASV <- as.character(d2_c_sum$ASV)
d2_c_phy_tab <- d2_c_ncbi %>%
  filter(taxonomy == "prey") %>%
  dplyr::select(ASV, ID, Order, Family) %>%
  left_join(d2_c_sum, by = "ASV") %>%
  dplyr::select(-ASV, -ID) #55 TOTAL

#create an order dataframe first by selecting only order column and
#then deleting everything in the order column that is blank 
d2_c_phy_tab_ord <- d2_c_phy_tab %>%
  dplyr::select(-Family) %>%
  na_if("") %>%
  drop_na(Order) #49 observations

#gather by sample and group by sample and Order to summarise how many are in each order
#(we are removing duplicate orders by combining them here). Then spread back out to a 
#community matrix with samples as the columns and orders in those samples as rows
d2_c_phy_tab_ord <- d2_c_phy_tab_ord %>%
  group_by(Order) %>%
  summarise(reads = sum(reads))  #14 ORDERS

#set rownames to ID column, and then remove that column
rownames(d2_c_phy_tab_ord) <- d2_c_phy_tab_ord$Order
d2_c_phy_tab_ord <- d2_c_phy_tab_ord %>%
  dplyr::select(-Order)

#transpose for phylogenetic analyses
d2_c_phy_tab_ord_t <- as.data.frame(t(d2_c_phy_tab_ord))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_d2c_ord <- picante::pd(d2_c_phy_tab_ord_t, ord_tree2, include.root=TRUE)
pd_d2c_ord$pipeline <- "d2_c"
#UNOISE 3 UC
u3_c_sum <- u3_c %>%
  gather(sample, reads, HEV07:HEV99) %>% #gather by ASV and sample
  group_by(ASV) %>% #group by ASV
  summarise(reads= sum(reads)) %>% #summarise the total reads in each ASV
  filter(reads > 0) #filter only those that are greater than 0

u3_c_ncbi$ASV <- as.character(u3_c_ncbi$ASV)
u3_c_sum$ASV <- as.character(u3_c_sum$ASV)
u3_c_phy_tab <- u3_c_ncbi %>%
  filter(taxonomy == "prey") %>%
  dplyr::select(ASV, ID, Order, Family) %>%
  left_join(u3_c_sum, by = "ASV") %>%
  dplyr::select(-ASV, -ID) #48 TOTAL

#create an order dataframe first by selecting only order column and
#then deleting everything in the order column that is blank 
u3_c_phy_tab_ord <- u3_c_phy_tab %>%
  dplyr::select(-Family) %>%
  na_if("") %>%
  drop_na(Order) #43 observations

#gather by sample and group by sample and Order to summarise how many are in each order
#(we are removing duplicate orders by combining them here). Then spread back out to a 
#community matrix with samples as the columns and orders in those samples as rows
u3_c_phy_tab_ord <- u3_c_phy_tab_ord %>%
  group_by(Order) %>%
  summarise(reads = sum(reads, na.rm = TRUE))  #11 ORDERS

#set rownames to ID column, and then remove that column
rownames(u3_c_phy_tab_ord) <- u3_c_phy_tab_ord$Order
u3_c_phy_tab_ord <- u3_c_phy_tab_ord %>%
  dplyr::select(-Order)

#transpose for phylogenetic analyses
u3_c_phy_tab_ord_t <- as.data.frame(t(u3_c_phy_tab_ord))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_u3c_ord <- picante::pd(u3_c_phy_tab_ord_t, ord_tree2, include.root=TRUE)
pd_u3c_ord$pipeline <- "u3_c"

#bind together
order_pd <- bind_rows(pd_d2uc_ord, pd_u3uc_ord, pd_d2c_ord, pd_u3c_ord)
order_pd <- order_pd %>%
  gather(measure, value, PD:SR)
#visualize, need to make prettier, and somehow standardize by species richness?
order_pd_graph <- ggplot(order_pd, aes(x = pipeline, y = value, color = measure)) +
  geom_point(size = 4) +
  labs(x = "Pipeline", y = "Order phylogenetic diversity and order richness", title = "Order PD and richness by pipeline") +
  theme_bw() 

#12.Phylogenetic Diversity of prey ASVs at FAMILY LEVEL #####
#using fam_tree2
#DADA2 Unclean
#create a family dataframe first by selecting only family column and
#then deleting everything in the family column that is blank 
d2_uc_phy_tab_fam <- d2_uc_phy_tab %>%
  dplyr::select(-Order) %>%
  na_if("") %>%
  drop_na(Family) #28 observations

#gather by sample and group by sample and Family to summarise how many are in each family
#(we are removing duplicate families by combining them here). Then spread back out to a 
#community matrix with samples as the columns and families in those samples as rows
d2_uc_phy_tab_fam <- d2_uc_phy_tab_fam %>%
  group_by(Family) %>%
  summarise(reads = sum(reads)) #17 families

#set rownames to ID column, and then remove that column
rownames(d2_uc_phy_tab_fam) <- d2_uc_phy_tab_fam$Family
d2_uc_phy_tab_fam <- d2_uc_phy_tab_fam %>%
  dplyr::select(-Family)

#transpose for phylogenetic analyses
d2_uc_phy_tab_fam_t <- as.data.frame(t(d2_uc_phy_tab_fam))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_d2uc_fam <- picante::pd(d2_uc_phy_tab_fam_t, fam_tree2, include.root=TRUE)
pd_d2uc_fam$pipeline <- "d2_uc"
#UNOISE Unclean##
#create a family dataframe first by selecting only family column and
#then deleting everything in the family column that is blank 
u3_uc_phy_tab_fam <- u3_uc_phy_tab %>%
  dplyr::select(-Order) %>%
  na_if("") %>%
  drop_na(Family) #25 observations

#gather by sample and group by sample and Family to summarise how many are in each family
#(we are removing duplicate families by combining them here). Then spread back out to a 
#community matrix with samples as the columns and families in those samples as rows
u3_uc_phy_tab_fam <- u3_uc_phy_tab_fam %>%
  group_by(Family) %>%
  summarise(reads = sum(reads, na.rm=TRUE)) #16 families

#set rownames to ID column, and then remove that column
rownames(u3_uc_phy_tab_fam) <- u3_uc_phy_tab_fam$Family
u3_uc_phy_tab_fam <- u3_uc_phy_tab_fam %>%
  dplyr::select(-Family)

#transpose for phylogenetic analyses
u3_uc_phy_tab_fam_t <- as.data.frame(t(u3_uc_phy_tab_fam))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_u3uc_fam <- picante::pd(u3_uc_phy_tab_fam_t, fam_tree2, include.root=TRUE)
pd_u3uc_fam$pipeline <- "u3_uc"
#DADA2 CLEAN
#create a family dataframe first by selecting only family column and
#then deleting everything in the family column that is blank 
d2_c_phy_tab_fam <- d2_c_phy_tab %>%
  dplyr::select(-Order) %>%
  na_if("") %>%
  drop_na(Family) #31 observations

#gather by sample and group by sample and Family to summarise how many are in each family
#(we are removing duplicate families by combining them here). Then spread back out to a 
#community matrix with samples as the columns and families in those samples as rows
d2_c_phy_tab_fam <- d2_c_phy_tab_fam %>%
  group_by(Family) %>%
  summarise(reads = sum(reads, na.rm=TRUE)) #17 families

#set rownames to ID column, and then remove that column
rownames(d2_c_phy_tab_fam) <- d2_c_phy_tab_fam$Family
d2_c_phy_tab_fam <- d2_c_phy_tab_fam %>%
  dplyr::select(-Family)

#transpose for phylogenetic analyses
d2_c_phy_tab_fam_t <- as.data.frame(t(d2_c_phy_tab_fam))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_d2c_fam <- picante::pd(d2_c_phy_tab_fam_t, fam_tree2, include.root=TRUE)
pd_d2c_fam$pipeline <- "d2_c"
#UNOISE CLEAn##
#create a family dataframe first by selecting only family column and
#then deleting everything in the family column that is blank 
u3_c_phy_tab_fam <- u3_c_phy_tab %>%
  dplyr::select(-Order) %>%
  na_if("") %>%
  drop_na(Family) # 24 observations

#gather by sample and group by sample and Family to summarise how many are in each family
#(we are removing duplicate families by combining them here). Then spread back out to a 
#community matrix with samples as the columns and families in those samples as rows
u3_c_phy_tab_fam <- u3_c_phy_tab_fam %>%
  group_by(Family) %>%
  summarise(reads = sum(reads, na.rm=TRUE)) #15 families

#set rownames to ID column, and then remove that column
rownames(u3_c_phy_tab_fam) <- u3_c_phy_tab_fam$Family
u3_c_phy_tab_fam <- u3_c_phy_tab_fam %>%
  dplyr::select(-Family)

#transpose for phylogenetic analyses
u3_c_phy_tab_fam_t <- as.data.frame(t(u3_c_phy_tab_fam))

#finally, use this community matrix for each pipeline plus the 
#meta phylogeny from both Unoise and DADA2 to calculate Faith's PD
#for each sample
pd_u3c_fam <- picante::pd(u3_c_phy_tab_fam_t, fam_tree2, include.root=TRUE)
pd_u3c_fam$pipeline <- "u3_c"

family_pd <- bind_rows(pd_d2uc_fam, pd_u3uc_fam, pd_d2c_fam, pd_u3c_fam)
family_pd <- family_pd %>%
  gather(measure, value, PD:SR)

family_pd_graph <- ggplot(family_pd, aes(x = pipeline, y = value, color = measure)) +
  geom_point(size = 4) +
  labs(x = "Pipeline", y = "Family phylogenetic diversity and family richness", title = "Family PD and richness by pipeline") +
  theme_bw()

#plot trees####
d2uc_tree <- d2_uc_phy_tab_ord %>%
  rename("d2uc" = "reads") %>%
  rownames_to_column("Order")

u3uc_tree <- u3_uc_phy_tab_ord %>%
  rename("u3uc" = "reads") %>%
  rownames_to_column("Order")

d2c_tree <- d2_c_phy_tab_ord %>%
  rename("d2c" = "reads") %>%
  rownames_to_column("Order")

u3c_tree <- u3_c_phy_tab_ord %>%
  rename("u3c" = "reads") %>%
  rownames_to_column("Order")

order_tree_pipe <- u3uc_tree %>%
  full_join(d2uc_tree, by = "Order") #%>%
  #left_join(u3c_tree, by = "Order") %>%
  #left_join(d2c_tree, by = "Order")

#set NA to zeros
order_tree_pipe[is.na(order_tree_pipe)] <- 0

#set rownames to order and then delete that column
rownames(order_tree_pipe) <- order_tree_pipe$Order
order_tree_pipe <- order_tree_pipe %>%
  dplyr::select(-Order)

#set to a matrix
order_tree_pipe <- as.matrix(order_tree_pipe)


#import taxonomies, set rownames, and make matrix
order_taxonomies <- read.csv(here("data", 
                                  "outputs",
                                  "taxonomic_data",
                                  "order_phylos.csv"))
rownames(order_taxonomies) <- order_taxonomies$Order
order_taxonomies <- as.matrix(order_taxonomies)

#from phyloseq package
#BiocManager::install("phyloseq", update = TRUE, ask = FALSE)
library(phyloseq)
order_ASV <- otu_table(order_tree_pipe, taxa_are_rows = TRUE)
order_taxa <- tax_table(order_taxonomies)
physeq_order <-  phyloseq(order_ASV, order_taxa, ord_tree2)

order_phy_graph <- plot_tree(physeq_order, nodelabf=nodeplotblank, plot.margin=0.6, label.tips = "taxa_names", shape = "samples")

#Family Tree now
d2uc_treef <- d2_uc_phy_tab_fam %>%
  rename("d2uc" = "reads") %>%
  rownames_to_column("Family")

u3uc_treef <- u3_uc_phy_tab_fam %>%
  rename("u3uc" = "reads") %>%
  rownames_to_column("Family")

d2c_treef <- d2_c_phy_tab_fam %>%
  rename("d2c" = "reads") %>%
  rownames_to_column("Family")

u3c_treef <- u3_c_phy_tab_fam %>%
  rename("u3c" = "reads") %>%
  rownames_to_column("Family")

family_tree_pipe <- u3uc_treef %>%
  full_join(d2uc_treef, by = "Family") #%>%
  #left_join(u3c_treef, by = "Family") %>%
  #left_join(d2c_treef, by = "Family")

#set NA to zeros
family_tree_pipe[is.na(family_tree_pipe)] <- 0

#set rownames to order and then delete that column
rownames(family_tree_pipe) <- family_tree_pipe$Family
family_tree_pipe <- family_tree_pipe %>%
  dplyr::select(-Family)

#set to a matrix
family_tree_pipe <- as.matrix(family_tree_pipe)

#import taxonomies, set rownames, and make matrix
family_taxonomies <- read.csv(here("data", 
                                   "outputs",
                                   "taxonomic_data",
                                   "family_phylos.csv"))
rownames(family_taxonomies) <- family_taxonomies$Family
family_taxonomies <- as.matrix(family_taxonomies)

#from phyloseq package
family_ASV <- otu_table(family_tree_pipe, taxa_are_rows = TRUE)
family_taxa <- tax_table(family_taxonomies)
physeq_family <-  phyloseq(family_ASV, family_taxa, fam_tree2)

family_phy_graph <- plot_tree(physeq_family, nodelabf = nodeplotblank, plot.margin=0.6, label.tips = "taxa_names", shape = "samples")
family_phy_graph

```

We looked at a bunch of different ways the pipelines performed both bioinformatically and ecologically. If you don't want to spend time on each one, you can jump to the pipeline performance [summary table](#pipelines), which provides the scores of each pipeline in each measure of performance. 

## a. Clustering specificity (positive and negative control ASVs)

Different clustering methods may have more or less specificity in their clustering. We checked for this by running several positive control samples and one negative control sample and looking at how different clustering pipelines assigned ASVs to these controls. The positive controls are cloned fungal species which Austen uses in his work. Because they are clones, they should map to one or very few ASVs. The negative controls were samples we ran through PCRs with no DNA in them and quantified to zero before submitting. Therefore, these should map to zero ASVs. **Takeaway**: smaller is better for both positive and negative control ASV counts. 

```{r control ASV counts, echo=FALSE}
control_count_plot
```

It seems that, first of all, cleaning removes all ASVs for the controls, which we would expect, since we filtered these based on known prey and predator ASVs. Furthermore, it seems that DADA2 does a better job of assigning fewer ASVs to positive controls than UNOISE3. Furthermore, the negative control had zero reads assigned to any reads in DADA2, while UNOISE3 assigned one ASV a value of 1 read for the negative control. 

On the other hand, when we look at how many sequence reads each control received (indicative of the pipeline to match DNA to denoised clusters), it looks like UNOISE3 does a much better job on average of mapping more sequence reads to positive controls:

```{r control ASV reads, echo=FALSE}
pos_reads
```

**Winner: UNOISE uncleaned**

## b. Total ASVs (richness)

A good clustering pipeline will be able to pick up all the diversity in a dataset. In this case, a higher number of total ASVs (roughly, species richness) means better clustering method, since we want to capture the greatest diversity possible. However, we will go into some more specific measures of richness (prey richness) next, since just the total number of ASVs may not actually be prey richness, but may instead be the pipeline clustering more predator or non-prey ASVs. 

We looked at both total ASVs produced by each pipeline as well as the number of ASVs each clustering pipeline assigned to each sample. 

```{r total ASVs, echo=FALSE}
total_asv_graph
```

The uncleaned datasets produce more ASVs, and DADA2 produces more total ASVs than UNOISE3.

**Winner: DADA2**

When we look at the total number of ASVs produced per sample, we see a different pattern, however: 

```{r total ASVs per sample, echo=FALSE}
ASV_sample_plot
```

Indeed, these differences among pipelines are statistically significant based on a random effects model with a full model structure of (comparing it to a null without pipeline, and then estimating marginal means between each pair):

```{r total ASV model, eval=FALSE}
tot_ASV_mod <- glmmTMB(value ~ pipeline + (1|sample),
                       data = by_sample_long,
                       family = "genpois")
```

With significant pairwise differences between all pipelines:

```{r marginal means of total ASV model, echo=FALSE}
pairs(model.emm_totASV)

plot(allEffects(tot_ASV_mod))
```

The takeaway here is that both UNOISE3 unclean and clean produce more ASVs than their DADA2 counterparts.

**Winner: UNOISE3 uncleaned and cleaned**

## c. Number of prey ASVs (diet richness) 

A higher total number of ASVs does not necessarily mean that a clustering pipeline is the best option, since these newly discovered ASVs may not actually be ASVs of interest, but rather ASVs of predators or other non-prey items (contamination, for example). Therefore, a better measure of whether a pipeline works best for the purposes of this study is to look at how well it clusters prey ASVs. We did this by combining taxonomic data to our ASV list, and assigning broad taxonomic categories to these ASVs. We combined taxonomic data from both GenBank (using BLAST and MEGAN) and from the BOLD IDEngine database. We combined taxonomic assignments from both sources and removed any assignment which did not match between these two databases. Anything that mapped to the predator Family, Genus, or Species was given a taxonomic category of "predator", anything that could possibly be prey (including arthropods and vertebrates in this dataset) were given a taxonomic category of "prey". Anything that was not given a specific taxonomic assignment but which could have been prey or predator was given the category of "unknown" (i.e. a BLAST taxonomic assignment of "Arthropoda"). There were other items in the dataset that were definitely not predators or prey (mostly fungi) and these were given a taxonomic assignment of "non-prey". Our final category included any ASV that was clustered but which was not assigned a taxonomy; this category was "no hit". 

We then subset just the prey ASVs from this dataset and compared the per sample number of prey ASVs assigned by each pipeline, which is visualized here:

```{r prey ASV graph, echo=FALSE}
prey_ASV_graph
```

We again looked for significant across group differences in prey ASVs using a mixed model (comparing it to a null without pipeline, and then estimating marginal means between each pair):

```{r prey ASV model, eval=FALSE}         
lme_prey_ASVs <- glmmTMB(ASVs ~ pipeline + (1|sample),
                 data = taxa_ASVs_prey,
                 family = "genpois")
```

And looked at pairwise differences between these groups: 
 
```{r marginal means of prey ASV model, echo=FALSE}                
pairs(model.emm_preyASV)

plot(allEffects(lme_prey_ASVs)) 
```

What we see is that cleaning does not significantly increase the number of ASVs assigned to prey items for either DADA2 or UNOISE3. However, what we see is that UNOISE3 assigns more prey ASVs to each sample, suggesting that UNOISE3 is better at detecting a greater prey richness than DADA2

**Winner: UNOISE unclean**

## d. Phylogenetic diversity of prey ASVs

Not only might one pipeline be better at detecting total prey richness, but might also be able to cluster a broader phylogenetic diversity of prey items. This might be especially important in systems where predators are generalists and feed on organisms across broad taxonomic groups. Because the number of ASVs assigned to prey per sample is fairly low (less than 10 per sample) and because we are interested in just detection here and not necessarily abundance variations among samples, we will just qualitatively assess Faith's PD for each pipeline, summing the prey ASVs for each pipeline. Furthermore, we will combine phylogenetic analyses at the Order and Family level, since we have good taxonomic representation at these levels (15 orders, 19 families)

```{r order level phylogenetic diversity, echo=FALSE, eval=FALSE}
plot_grid(order_pd_graph, order_phy_graph, align="h")
```

UNOISE3 unclean picks up the greatest phylogenetic diversity. It is important to note that this is in spite of the fact that order richness is greater in the DADA2 dataset. UNOISE3 unclean has the lowest phylogenetic diversity, which is probably because we trained the cleaning program with DADA2 and some of the phylogenetic diversity of the UNOISE3 unclean dataset was removed. Based on the phylogenetic tree, DADA2 picked up Lepidoptera (moths and butterflies) and Sarcoptiformes (mites), while UNOISE3 picked up Squamata (geckos). 

```{r family level phylogenetic diversity, echo=FALSE, eval=FALSE}
plot_grid(family_pd_graph, family_phy_graph, align ="h")
```

Again, UNOISE3 unclean picks up the greatest phylogenetic diversity. It is important to note that this is in spite of the fact that, again, family richness is greater in the DADA2 dataset. UNOISE3 unclean has the lowest phylogenetic diversity, which is probably because we trained the cleaning program with DADA2 and some of the phylogenetic diversity of the UNOISE3 unclean dataset was removed. DADA2 picks up Formicidae (ants) and Suidasiidae (mites), while UNOISE3 picks up Xiphydridae (wasps) and Gekkoniidae (geckos). 

**Winner: UNOISE unclean**

## e. Prey read abundance

Similar to the number of ASVs assigned to prey, the number of sequence reads assigned to each of these ASVs is important because rarer prey items are more likely to be detected the greater abundance each prey ASV is in each sample. 

We can visualize the number of reads of each ASV in each sample:

```{r prey reads graph, echo=FALSE}
prey_reads_graph
```

And again, we ran a mixed model to determine whether there are significant among pipeline detections in prey reads (comparing it to a null without pipeline, and then estimating marginal means between each pair):

```{r prey reads model, eval=FALSE}
read_mod <- glmmTMB(reads ~ pipeline + (1|sample),
                 data = taxa_reads_prey,
                 family = "genpois")
```

```{r marginal means for prey reads model}
pairs(model.emm_preyreads)
```

Cleaning did not significantly increase prey read abundance. UNOISE3 produced more prey reads per ASV per sample than DADA2

**Winner: UNOISE3 unclean**

## f. Percent of ASVs that are prey

So far, we have been assuming that the total number of ASVs is independent of sequencing depth, which we know is not the case. Therefore, we ran the above ASV model again correcting for sequencing depth (using an offset of the total number of ASVs). These data can then be interpreted as the percent of all ASVs assigned to prey. 

```{r prey prop ASV graph, echo=FALSE}
prey_prop_graph
```


```{r prey ASV prop model, eval=FALSE}
prey_prop_mod <- glmmTMB(prey ~ pipeline + (1|sample),
                          data = ASV_totals_samples,
                          family = "genpois",
                         offset = log(tot))
```

```{r marginal means of prey ASV prop model, echo=FALSE}
pairs(model.emm_preyprop)

plot(allEffects(prey_prop_mod))
```

Unsurprisingly, cleaning increases the total proportion of prey ASVs in each sample. DADA2 has a higher proportion of prey ASVs than UNOISE3 for both clean and uncleaned datasets.

**Winner: DADA2 clean**

## g. Percent of reads that are prey

Again, we have been assuming that the total number of reads is independent of sequencing depth, which we know is not the case. Therefore, we ran the above reads model again correcting for sequencing depth (using an offset). These data can then be interpreted as the percent of all reads assigned to prey. 

```{r prey read proportion graph, echo=FALSE}
prey_rprop_graph
```


```{r prey read proportion model, eval=FALSE}
prey_rprop_mod <- glmmTMB(prey ~ pipeline + (1|sample),
                         data = read_totals_samples,
                         family = "genpois",
                         offset = log(tot))
```

```{marginal means of the prey read proportion model, echo=FALSE}
pairs(model.emm_preyrprop)
```

Cleaning increased the total proportion of reads that are assigned to prey ASVs. There is no difference in the proportion of prey reads in samples for either DADA2 or UNOISE3. 

**Winner: cleaned datasets**

## h. Amount of known diet reads

We know we fed lab organisms a specific diet item (*Oxya japonica*), and so we should trust the pipeline that detects this prey item better.

Let's look at detection across samples of this prey item (we subset our dataset to just be those that we fed the item to):

```{r known prey plot, echo=FALSE}
known_prey_plot
```

Again, we built a mixed model that we compared to a null model: 

```{r known prey model, eval=FALSE}
known_reads_mod <- glmmTMB(value ~ pipeline + (1|sample),
                          data = known_reads_long,
                          family = "genpois")
```

And looked at pairwise differences:

```{r marginal means known prey model, echo=FALSE}
pairs(model.emm_knownprey)

plot(allEffects(known_reads_mod))
```

Cleaned datasets have significantly more reads of the known prey items per sample for DADA2, however cleaning did not increase detection of known prey for UNOISE3. UNOISE3 has better detection of known prey items. 

## Pipeline Performance Summary {#pipelines}

Compiling the results from this, we get a summary of all the measures of pipeline performance. In the case of a non-significant difference between pipelines, the pipeline with the most parsimonious protocol (i.e. no cleaning) will win. In the case that the parsimony is the same between pipelines, none is considered to be outperforming. (in the following table, an "X" designates the best performing pipeline, either by significant difference between groups or because it is the most parsimonious of a tie, "NS" signifies that these pipelines performed equally well to the winning, parsimonious pipeline, and "TIE" signifies that these pipelines performed equally well and have the same parsimony.)

```{r summary table of pipelines, echo=FALSE}
row1 <- c("Measure/Pipeline", "DADA2 UC", "UNOISE3 UC", "DADA2 C", "UNOISE3 C")
row2 <- c("Positive control ASVs", "", "X", "", "")
row3 <- c("Negative conotrol ASVs", "X", "", "NS", "NS")
row4 <- c("Total ASVs", "X", "", "", "")
row5 <- c("ASVs per sample", "", "X", "", "NS")
row6 <- c("Prey ASVs", "", "X", "", "")
#row7 <- c("PD - Order", "", "X", "", "")
#row8 <- c("PD - Family", "", "X", "", "")
row9 <- c("Prey reads", "", "X", "", "")
row10 <- c("Prey ASV %", "", "", "X", "")
row11 <- c("Prey read %", "", "", "TIE", "TIE")
row12 <- c("Known Diet", "", "X", "", "NS")

pipeline_table <- as.data.frame(rbind(row1, row2, row3, row4, row5, row6, row9, row10, row11, row12))
colnames(pipeline_table) <- pipeline_table$row1
knitr::kable(pipeline_table[2:12, ], col.names = row1, row.names=FALSE)

```

From this, we see that in most cases, the uncleaned pipelines perform equally well or better than the cleaned pipelines. So cleaning does not add much to our bioinformatic performance nor our ecological inference from this dataset. As a result, for our analyses of sterilized vs. unsterilized individuals (both field and lab), the best options in terms of time are both unclean DADA2 and UNOISE3. The "winner" between these two pipelines is unclear - UNOISE3 outperformed ecologically (providing more diet data to work with); conversely, DADA2 outperformed bioinformatically (controls mapped more accurately). 

#### Takeaway: either UNOISE3 or DADA2 will give you good diet data with good specificity. The choice, then, may be dependent on access rather than performance. While DADA2 is open access and user-friendly in R, it takes longer to run than UNOISE3; conversely, while UNOISE3 runs much more quickly, it is only free in a 32-bit version that does not run on some new operating systems (e.g. 64-bit Mac Catalina OS). These and other costs-benefits are reviewed more thoroughly in Nearing et al. (2018)